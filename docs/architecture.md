<!--
  This document was initially generated with the help of Azure OpenAI.
  Please review and adapt it as needed.
-->

# Architecture Document — hackathon2025

Last updated: (generated by AI) — please review and refine.

## 1. Introduction

This small demo Spring Boot application (project name: hackathon2025) demonstrates a minimal web application that serves both server-rendered HTML pages (Thymeleaf) and simple JSON REST endpoints. It is intended as a lightweight demo for REST + UI interactions and for automated test generation workflows.

What the application does (based purely on the source):
- Hosts a server-rendered index page at `/` that shows a title and a button "Test REST". Clicking the button calls `/api/hello` and displays the returned JSON.
- Provides a follow-up demo page (`followup.html`) that exercises several REST endpoints (`/api/hello`, `/api/hello2`, `/api/hello3`, `/api/goodby`, `/api/goodnight`) via client-side JavaScript fetch calls and displays results on the page.
- Exposes three small REST controllers that return simple JSON maps with message strings.

Main technologies used:
- Java 17+ (typical for Spring Boot projects) and Spring Boot framework
- Spring Web (REST controllers and MVC)
- Thymeleaf templates for server-side HTML rendering
- REST endpoints returning JSON (via Map<String,String>)
- Automated tests and workflows mentioned: JUnit (unit tests) and Playwright (UI/API tests). The repository contains CI workflows that use Azure OpenAI to generate or update tests and documentation (see CI/CD section).

## 2. Architecture Overview

High-level architecture:
- Backend: Spring Boot application with entry point `Hackathon2025Application` that starts the embedded server and component scanning.
- Controllers:
  - REST controllers annotated with `@RestController` handle API requests under `/api/...`.
  - A Web MVC controller (`WebController`) annotated with `@Controller` returns Thymeleaf views.
- UI Templates: Thymeleaf templates in `src/main/resources/templates` render pages; client-side JavaScript (vanilla) issues `fetch` calls to the REST endpoints.
- No persistence layer, security or complex service layer is present — controllers directly produce responses.

How the main application class wires things together:
- `Hackathon2025Application` is annotated with `@SpringBootApplication`. When run, Spring Boot auto-configures MVC, REST support, Thymeleaf template engine and component scanning so the controller classes are discovered and used.

Request flow (typical):
1. Browser requests a UI page (e.g. GET `/`).
2. `WebController.index()` executes, places a `title` attribute into the model and returns the logical view name `index`.
3. Thymeleaf renders `index.html` using the model and the HTML is returned to the browser.
4. Browser JavaScript (on button click) issues a fetch to a REST endpoint (e.g. `/api/hello`).
5. `HelloRestController.hello()` runs, returns a Map that Spring serializes to JSON.
6. Browser receives JSON and updates the DOM accordingly.

Alternative: Browser can hit the REST endpoints directly (e.g. POSTman or UI pages), and get JSON responses.

## 3. Components and Responsibilities

Application entry:
- Hackathon2025Application.java
  - Starts Spring Boot via `SpringApplication.run(...)`.

REST controllers:
- HelloRestController
  - Mappings:
    - GET `/api/hello` → returns `{ "message": "Hello again and again from REST API for Hackathon 2025!" }`
    - GET `/api/hello2` → returns `{ "message": "Dummy text for hello2" }`
    - GET `/api/hello3` → returns `{ "message": "Another dummy text for hello3" }`
  - Purpose: simple demo endpoints to return JSON messages.

- GoodbyRestController
  - Mappings:
    - GET `/api/goodby` → accepts optional `name` request parameter (default `"Gast"`) and returns a personalized goodbye message, e.g. `{ "message": "Goodbye, <name>, from REST API for Hackathon 2025!!!!" }`
    - GET `/api/goodnight` → returns `{ "message": "Good night from REST API for Hackathon 2025!!!" }`
  - Purpose: shows a query-parameter-driven endpoint and another simple message.

Web controller:
- WebController
  - Mapping: GET `/` → sets model attribute `title` = `"Hackathon 2025 Demo"` and returns the `index` Thymeleaf view.
  - Purpose: provide the landing page that demonstrates REST interaction.

HTML templates
- templates/index.html
  - Shows the page title (from model) and a button "Test REST". The button runs client-side JS to fetch `/api/hello` and then displays the JSON in an element with id `apiResult`.
  - Example of client-side fetch logic:
    - async function callApi() { const res = await fetch('/api/hello'); const j = await res.json(); ... }

- templates/followup.html
  - A richer demo page that exposes buttons to call `/api/hello`, `/api/hello2`, `/api/hello3`, `/api/goodby` (with an input field) and `/api/goodnight`. Responses are displayed in `helloResult` and `goodbyResult` paragraphs.
  - Purpose: manual exploratory page to try different API endpoints.

Data formats:
- All REST endpoints return Map<String,String>. Spring automatically serializes Maps to JSON objects.

## 4. UI and REST Interaction

Index page behavior:
- The index page (`/`) displays the title and a "Test REST" button.
- When the button is clicked, client-side JavaScript executes a fetch:
  - fetch('/api/hello') → receives JSON like { "message": "Hello again ..." } and writes the JSON string into the DOM element with id `apiResult`.

Follow-up page:
- `followup.html` provides interactive buttons that call the three hello endpoints and the two goodby endpoints.
- The goodby endpoint `/api/goodby` is invoked with a query parameter `name` taken from the input field. If the input is empty, the endpoint receives no parameter and uses its default value `Gast`.

UI ↔ REST interaction summary:
- The UI pages use plain fetch calls from the browser; there is no client-side framework or special API layer. The controllers are simple and return immediate JSON results. This direct coupling works for a demo but lacks separation of concerns expected in larger apps.

## 5. Testing Strategy

The repository includes (or integrates with) automated testing in three layers:
- Unit tests (JUnit)
  - Basic unit/integration tests for controller endpoints are expected (Spring Boot testing with MockMvc or plain unit tests).
  - Some tests in the repo may have been generated or updated automatically using Azure OpenAI assistance (see CI section). These tests assert the presence and correctness of returned JSON messages and status codes.

- UI/API tests (Playwright)
  - End-to-end tests exercise the UI pages and verify the fetch behavior and displayed results (for example clicking "Test REST" and asserting that `apiResult` contains expected JSON).
  - Playwright tests are used to run the browser-level scenarios and are also mentioned as being generated/updated by an AI-assisted workflow.

- Test coverage focus
  - Typical coverage: basic happy-path behavior of REST endpoints and the client-side interactions triggered by the sample pages. The tests verify HTTP 200 responses and response JSON contents. They do not (currently) cover security, persistence, or edge/error cases.

Note: The repository indicates some tests and Playwright scripts are generated or updated by Azure OpenAI workflows; all generated tests should be reviewed by developers for correctness and completeness.

## 6. CI/CD and AI-Assisted Workflows

This project is designed to be used with GitHub Actions workflows that perform the following (as configured in the repository workflows):
- Generate or update Java unit tests using Azure OpenAI (automated test suggestion).
- Generate or update Playwright UI and API tests using Azure OpenAI.
- Regenerate or update the architecture documentation (this file) using an AI workflow, producing a draft that should be reviewed by humans.
- Run Maven build and tests (mvn test) and run Playwright tests as part of CI.
- When generation steps produce artifacts (tests, docs), the workflow commits those generated artifacts back to the pull request branch (not directly to the `main` branch) — ensuring humans can review changes before merging.

Important: This document (docs/architecture.md) was generated by an AI-assisted workflow. It is a useful starting point, but it must be validated and edited by project maintainers to ensure technical correctness, completeness and style.

## 7. Limitations and Next Steps

Limitations (observed from the code):
- No persistence layer (no database or repository abstractions).
- No service/business layer: controllers return responses directly, mixing responsibilities.
- No validation or structured DTOs — endpoints accept raw request parameters and return Map<String,String>.
- No global error handling, security, logging or metrics integration.
- Tests and generated artifacts may be syntactically correct but require human review for meaningful assertions and maintainability.

Suggested next steps:
- Introduce service layer classes to encapsulate business logic and make controllers thin.
- Replace Map<String,String> responses with strongly typed DTO classes (POJOs) for clearer contracts.
- Add input validation (Spring Validation / @Valid) and a global exception handler (@ControllerAdvice).
- Add logging and structured log format; consider correlation IDs for tracing.
- Add persistence if required (Spring Data repositories + database configuration).
- Harden endpoints: add authentication/authorization if the app moves beyond a public demo.
- Expand test coverage to include negative/error cases, performance tests and integration tests with embedded server.
- Create documentation guidelines and keep this generated architecture doc under human review as the ground truth evolves.

Assumptions and notes:
- This document is based solely on the provided Java classes and HTML templates.
- CI workflow details and test generation behavior are summarized from repository metadata and project guidelines — exact workflow steps should be inspected in the .github/workflows directory for precise implementation.

If you are joining the project: please run the application locally (mvn spring-boot:run), open `http://localhost:8080/` and `http://localhost:8080/followup.html` to interact with the demo and read the generated tests to see what is covered. Welcome — and please review and improve both tests and this documentation.
