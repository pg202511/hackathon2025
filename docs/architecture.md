<!--
  This document was initially generated with the help of Azure OpenAI.
  Please review and adapt it as needed.
-->

# Architecture and Technical Overview — hackathon2025

This document describes the architecture, components, and workflows of the hackathon2025 demo Spring Boot application. It is intended as an onboarding and reference document for new developers. It summarizes the code and templates present in the repository and explains how the UI, REST endpoints, testing, and CI workflows are organized.

Note: this document was generated by an AI-assisted workflow and should be reviewed and refined by project maintainers before relying on it for decisions.

## 1. Introduction

What the application does
- hackathon2025 is a small demo web application that exposes a set of simple REST endpoints and serves a couple of HTML pages using Thymeleaf templates.
- The REST API endpoints return small JSON payloads (maps of strings and numbers).
- The HTML pages include client-side JavaScript that calls the REST endpoints (via fetch) and shows the JSON responses on the page — this demonstrates browser ↔ REST interaction.

Main technologies
- Java (language)
- Spring Boot (web application framework)
- Spring Web / Spring MVC (controllers, REST endpoints)
- Thymeleaf (server-side HTML templates)
- Playwright (used for UI/API tests in repository workflows)
- JUnit (unit tests)
- Azure OpenAI (used by automated CI workflows to generate/update tests and docs) — see CI/CD section below.

## 2. Architecture Overview

High-level architecture
- Single Spring Boot application (entry point: Hackathon2025Application).
- Controllers provide two types of concerns:
  - REST controllers (annotated with @RestController) under `/api/*` that return JSON.
  - A web controller (annotated with @Controller) that returns view names and supplies model attributes for Thymeleaf templates.
- Static HTML templates (Thymeleaf) located under `templates/` are rendered by the server and served to browsers; client-side JavaScript then calls REST endpoints.

How the application is wired together
- The class Hackathon2025Application is annotated with @SpringBootApplication and contains the main method which boots the Spring context.
- Spring Boot auto-configuration sets up embedded Tomcat, component scanning, and MVC configuration so controllers and templates are discovered automatically.
- Controllers are simple Spring-managed beans discovered by component scanning and mapped via annotations like @GetMapping.

Request flow (typical)
- Browser → GET `/`:
  - WebController#index is invoked, it adds a `title` model attribute and returns view name `index`.
  - Thymeleaf renders `templates/index.html`, embedding the `title` value.
- Browser (client JS) → fetch `/api/hello`:
  - HelloRestController#hello returns a Map that Spring MVC converts to JSON and returns to the client.
- More generally:
  - Browser → Controller → either a rendered View (Thymeleaf) or a JSON response from a REST endpoint.

## 3. Components and Responsibilities

Main Java components

- Hackathon2025Application
  - Spring Boot entry point; nothing custom beyond standard bootstrapping.

- WebController
  - Handles the root route (`/`).
  - Adds an attribute `title` to the model and returns the `index` view.
  - This ties server-side values into the index Thymeleaf template.

- HelloRestController
  - Paths:
    - GET `/api/hello` → returns {"message":"Hello again and again from REST API for Hackathon 2025!"}
    - GET `/api/hello2` → returns a dummy text in `message`
    - GET `/api/hello3` → returns another dummy text in `message`
  - All endpoints return Map<String,String> which Spring automatically serializes to JSON.

- GoodbyRestController
  - Paths:
    - GET `/api/goodby?name=...` → returns {"message":"Goodbye, <name>, from REST API for Hackathon 2025!!!!"}
      - If `name` is omitted, defaults to "Gast".
    - GET `/api/goodnight` → returns a fixed good-night message.
  - Demonstrates use of @RequestParam with a default value.

- FibonacciRestController
  - Path:
    - GET `/api/fibonacci?number=N` → returns a map with `number` and `fibonacci` computed for the requested index.
    - If `number` < 0, returns an error map: {"error":"Die Zahl muss >= 0 sein."}
  - The Fibonacci value is computed iteratively in calculateFibonacci to avoid recursion and stack issues for moderate N.
  - Response shape is Map<String,Object> to allow both numeric and error values.

HTML templates (purpose)
- templates/index.html
  - Rendered at `/`.
  - Displays the title (from the model) and includes a "Test REST" button.
  - Client JavaScript calls `/api/hello` and writes the JSON result into the page element with id `apiResult`.
- templates/followup.html
  - Not wired by any controller in provided code (no mapping to `/followup`), but present as a demo page.
  - Contains buttons and inputs to exercise multiple REST endpoints:
    - Calls `/api/hello`, `/api/hello2`, `/api/hello3`
    - Calls `/api/goodby?name=...` and `/api/goodnight`
  - Demonstrates client-side fetch usage and rendering returned JSON into DOM elements.

## 4. UI and REST Interaction

Index page behavior
- The index page receives the `title` model attribute from WebController.
- It contains a button "Test REST" which, when clicked, runs client-side JavaScript that fetches `/api/hello`.
- The response is parsed as JSON and displayed as stringified JSON in the DOM.

Example (simplified):
- Client calls:
  fetch('/api/hello').then(r => r.json()).then(j => ...);
- Server responds with:
  {"message":"Hello again and again from REST API for Hackathon 2025!"}

Followup page behavior
- followup.html contains multiple buttons and a text input to interact with HelloRestController and GoodbyRestController.
- Each button triggers a fetch to the corresponding `/api/...` endpoint and prints the JSON result into specific <p> nodes.
- The Goodby endpoint demonstrates passing a query parameter (`name`) from an input field.

How UI interacts with REST controllers
- All UI → API interaction is via standard fetch() calls using GET and query parameters.
- Controllers return Java Map objects; Spring converts these to JSON responses automatically (Content-Type application/json).
- No form submissions, CSRF tokens, or POST endpoints are used in the provided templates.

## 5. Testing Strategy

Unit tests (JUnit)
- The project uses JUnit for unit testing of server-side logic (standard for Java/Spring projects).
- The codebase is small and unit tests typically cover controller responses and computational logic (e.g., Fibonacci calculation).
- Some unit tests in the repository are generated or updated by an automated AI-assisted workflow (Azure OpenAI) — these may provide baseline assertions for endpoints and error cases.
- Example test targets:
  - Ensure `/api/hello` returns the expected message.
  - Verify `/api/goodby` respects the `name` parameter default.
  - Test negative input handling for `/api/fibonacci`.

UI/API tests (Playwright)
- Playwright is used to drive browser-like tests that exercise UI pages and API integrations.
- Playwright tests:
  - Open the index or followup pages, click buttons, and assert that the UI displays JSON returned by API endpoints.
  - Directly call API endpoints and assert response structure and content.
- Some Playwright tests are generated/updated via Azure OpenAI in CI to keep coverage aligned with code changes.

Note: exact test files are not repeated here; the intent is to cover REST contract and end-to-end UI flows.

## 6. CI/CD and AI-Assisted Workflows

Overview
- The repository includes (or is intended to include) GitHub Actions workflows that automate several tasks:
  - Generate/update Java unit tests using Azure OpenAI (to create or refresh tests that assert current behavior).
  - Generate/update Playwright UI/API tests using Azure OpenAI.
  - Generate/update this architecture document (docs/architecture.md) as part of the automated documentation workflows.
  - Run Maven unit tests and Playwright tests in CI to validate changes.
  - Commit generated/updated artifacts (tests, docs) back to the pull request branch — note: the workflow commits to the PR branch, not directly to main.

Important operational notes
- The AI-assisted test generation is intended to speed up coverage but requires human review: automatically generated tests can be useful starting points but may be brittle or make assumptions that need correction.
- This architecture document itself was produced by such a workflow and must be reviewed and refined by humans prior to acceptance.

## 7. Limitations and Next Steps

Current limitations (observed in code)
- No persistence layer: application state is ephemeral and computed on demand.
- No service layer: controllers contain routing and logic access; adding services would improve separation of concerns.
- Minimal validation and error handling: only Fibonacci checks negative numbers; other endpoints accept any input.
- No security: endpoints are public, no authentication/authorization considered.
- Internationalization: some messages are German or English; message handling is hard-coded.
- Potential numeric limits for Fibonacci: uses long but no upper bound checks; large `number` values may overflow or be slow.

Suggested next steps
- Introduce service classes (e.g., FibonacciService) to encapsulate computation and make unit testing easier.
- Add DTOs and validation (Spring's @Valid + constraint annotations) for request parameters.
- Add centralized exception handling (ControllerAdvice) returning consistent error structures.
- Introduce persistence if needed (JPA repositories) for stateful features.
- Add OpenAPI/Swagger documentation for the REST API to make endpoints discoverable.
- Harden CI: add static analysis (SpotBugs/Checkstyle), automated formatting, and stricter test assertions.
- Add rate limiting and security (Spring Security) for production-readiness.
- Add logging and metrics (Micrometer) to observe runtime behavior.
- Add tests covering edge cases (very large fibonacci numbers) and concurrency.

---

If you have questions about any controller or template in the repository, or would like a proposed package structure and example service/controller refactor, I can produce a follow-up design and code examples. Remember to review the AI-generated tests and this document before merging them into main.
